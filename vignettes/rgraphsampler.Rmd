---
title: "Working with graph_sampler from R"
author: "Witold Wiecek"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Working with graph_sampler software from R}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
  
```{r setup, include = FALSE}
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
fig.width = 8, fig.height = 5)

set.seed(1245)
```

The aim of this short vignette is to introduce `rgraphsampler`, a simple R interface for calling [graph_sampler](http://www.nongnu.org/graphsampler/) software from R and manipulating the results, designed primarily for non-Linux users. 

*Graph_Sampler* is a graph or network inference and simulation package developed by Frederic Bois. *Graph_Sampler* allows you to generate structured random graphs and perform fully Bayesian inference on Bayesian networks' or dynamic Bayesian networks' structure. Markov chain Monte Carlo algorithms are used to those effects. The code is standard C. It uses flex and bison for development, and optionally libgsl at run-time. It is distributed under a GNU GPL license and maintained at [Savannah](https://savannah.nongnu.org/projects/graphsampler/). If you are not familiar with *graph_sampler*, please refer to the project's website, <http://www.nongnu.org/graphsampler/>.

The objective of `rgraphsampler` is two-fold:

1. To make available to R users a convenient tool for performing inference in *Graph_Sampler*
2. To make working with outputs of *Graph_Sampler* analyses easier.


## Graph_sampler basics

This vignette is not an introduction to *graph_sampler* itself, for which complete user documentation is [available online](http://www.nongnu.org/graphsampler/graph_sampler.html). 

> Graph_Sampler is an inference and simulation tool for networks (understood as graphs). It can simulate random graphs for general directed graphs (eventually cyclic) (see Bibliographic References: Bois & Gayraud 2015; Datta et al. 2017) or for directed acyclic graphs (Bayesian networks). The graphs are generated by Markov chain Monte Carlo (MCMC) simulations and their structure can be specified to follow probabilistic properties through the use of prior distributions. Graph_sampler lets you also infer about graph structure through the joint use of priors and data about node values (via a likelihood function).
>
> __General procedure__ 
>
>You write an input files and run compiled graph_sampler program. The input files specifies the kind of graph to simulate, some simulation parameters and output options, the priors you want, the eventual data and their likelihood (see Running Graph_Sampler). The simulation output is written to standard ASCII files. After simulations, you can also check the convergence of the MCMC sampling.
>
> No knowledge of computer programming is required, unless you want to tailor the program to special needs (in which case you may want to contact us).

As indicated, the basics of the methodology are covered by two papers: [Bois and Gayraud](http://arxiv.org/abs/1311.6443), [Datta et al](https://link.springer.com/article/10.1007%2Fs00180-017-0719-1), although new features have been added to the software since.



## `rgraphsampler` basics

C code included in this package requires compilation from source. Installing from GitHub under Windows, [RTools](https://cran.r-project.org/bin/windows/Rtools/) should be enough to compile code.

```{r}
library(rgraphsampler)
```

*graph_sampler* scripts are ran with the `rgs()` function; `rgs(file_in, file_out)` is equivalent to `graph_sampler <file_in> <file_out>`.

R version is fully featured in that it directly uses unmodified *graph_sampler* code within the package. However, GSL versions of functions are disabled to decrease dependencies for non-Linux users. Therefore the results obtained through R version should be equivalent to running non-GSL version of *graph_sampler*.

### Note on known bugs 

This tool is still a prototype. Due to nature of `bison` parsing engine (the tool for reading in input scripts), when errors occur (e.g. due to malformed input script) the parser, it is recommended to unload the dynamic library before working with any other scripts, i.e. . This helps R delete static variables generated by the parser, which may not reset on errors.

```
unloadNamespace("rgraphsampler")
```

## Preparing scripts and running *graph_sampler*

Main function of the package is `rgs()`, which calls on *graph_sampler* and, if requested, automatically loads outputs into R.

30 scripts are included in the package for testing and demonstration. All of them are available to users:

```{r, eval = FALSE}
list.files(system.file(package="rgraphsampler", "test_scripts"))
```

It's easy to browse the scripts:

```{r, eval = FALSE}

script_file <- system.file(package="rgraphsampler",
                           "test_scripts", "script_test_1.txt")
file.show(script_file)
```

Once a valid input script has been prepared, `rgs()` runs the *graph_sampler* program. Note that `rgs` will always generate output files (exactly the same as when running *graph_sampler*) and these outputs 

```{r, eval = FALSE}
rgs(file_in = script_file, file_out = "gs_output", return_result = FALSE)
```

By default `rgs` will `return_result`, i.e. after sampling is complete, the results will be loaded into R automatically. We illustrate this next.



## Example: analysing linear Gaussian model

### Generating graphs in rgraphsampler 



### Generating data in rgraphsampler

While *graph_sampler* scripts cannot be generated from R, it is often the case that data that the scripts use will be prepared in R. A simple function for generating linear models of Gaussian variables is included in `rgraphsampler`; it is called `gen_data_from_graph`. The purpose of this function is not only for testing code validity or generating examples, but primarily for model building -- it is recommend to test model performance on simulated data in all "real" analyses. For continuous variables, *graph_sampler* assumes that for $x_{i,n}$, i.e. $n$-th observation of $i$-th node

$$x_{i,n} = \sum_{j = 1, \ldots, |Pa(X_i)|}\beta_{ji}x_{j,n} + \alpha_i + \epsilon_{i,n}$$
where $\epsilon_i$ is i.i.d. $\mathcal{N}(0, \sigma_i)$. For SCCs analogous multivariate model is used; `gen_data_from_graph` allows for specification of all $\beta$, $\alpha$, $\sigma$ parameters, as well as creation of cyclical structures (multivariate Gaussian variables of any size) within the graph. 

```{r}
g_adj <- matrix(c(
  0, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 
  0, 0, 0, 0, 1, 0, 0, 
  0, 0, 1, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 1,
  0, 0, 0, 0, 0, 0, 0), 7, 7, byrow=T)
data <- gen_data_from_graph(beta = g_adj, alpha = rep(0, 7),
                            loop = c(1,2,3,3,3,4,5), cor_loop = .9,
                            ndata = 200)
```

Before analysing we can visualise the true causal graph and the sampled data:

```{r}
l <- data.frame(x = c(-2, -1, -0.2,  0.6,  0.2,  1.0,    2) / 2,
                y = c( 0,  0,    0, -2/3,  2/3,  2/3,  2/3) )

gr <- igraph::graph_from_adjacency_matrix(g_adj)
igraph::V(gr)$name <- c("P", LETTERS[1:5], "Q") #set vertex labels
fig1 <- plot(gr, layout = as.matrix(l), rescale = F,
             vertex.frame.color = "black", vertex.label.color = "black", 
             vertex.size = 1.5*20, vertex.color = "white",
             edge.color = "black", edge.arrow.size = .5)
```

```{r}
pairs(data)
```



### Data script
A generic script for working with the data generated above is included in the package.

```{r}
in_file <- system.file(package = "rgraphsampler", "scripts", "script_vignette")
```

Once again, the built-in scripts can be easily reviewed using `file.show()` command. We print it out here to also demonstrate simplicity of *graph_sampler*'s syntax:

```
n_runs    = 4E6;
n_burn_in = 2E6;

random_seed = 3456;

n_nodes = 7;

hypergraph = true;
bayesian_network = false;

initial_adjacency = matrix{empty};
hyper_pB = matrix{equanimous};

degree_prior      = true;
gamma_degree      = 3.0;
motif_prior       = false;
concordance_prior = false;

scc_prior         = true;
gamma_scc         = 1;
maximum_scc_size  = 3;

likelihood = constant_gamma;

extra_df_wishart          = 1;
scale_wishart_diagonal    = 1;
scale_wishart_offdiagonal = 0.5;

save_best_graph              = true;
save_edge_probabilies        = true;
n_saved_adjacency            = 100;

n_data = 200;
data = import_file{"rdata.dat"};
```

In the last line, the script calls for data inputs to be imported from `rdata.dat` file. We can prepare that file directly from R:

```{r}
write(data, file = "rdata.dat", ncolumns = 200)
```


We then run graph_sampler from R and automatically store outputs in an object of class `rgs`. Network nodes can also be labelled at this stage:

```{r,eval=TRUE}
gs_fit <- rgs(in_file, 
              node_names = c("P", LETTERS[1:5], "Q"))
```

Default `summary` and `plot` methods are implemented for `rgs` outputs. 

```{r}
summary(gs_fit)
```

Since the default plotting method uses the `igraph` package, extra arguments can be passed to improve the plots. By passing an additional argument we can also remove edges with probabilities lower than 25% from being displayed, for clarity of presentation.


```{r, fig.width = 8, fig.height=4}
par(mfrow = c(1,3), oma = rep(0, 4), mar = rep(1,4))
plot(gs_fit, .25,
     layout = as.matrix(l), 
             vertex.frame.color = "black", vertex.label.color = "black", 
             vertex.size = 1.5*20, vertex.color = "white",
             edge.color = "black", edge.arrow.size = .5)
```


## Conclusion

The short example which we presented here is only a proof of concept for an R package. However, the R package in its current format offers all of the features of *graph_sampler*'s C version and allows us to perform fully Bayesian structure learning with only a few lines of code, entirely in R.


```{r, include=FALSE}
unloadNamespace("rgraphsampler")
```
